#!/bin/bash

# Script for playing video in ascii
#
# Required programs:
#>	jp2a
#>	ffmpeg

if [[ ! -z $1 ]]; then
	VIDEO="$1"
else
	echo "Error: Video not specified." 1>&2
	exit 1
fi

VIDEO_PATH="$PWD/$VIDEO"

[[ -z $WIDTH ]] && WIDTH=200
[[ -z $PRELOAD ]] && PRELOAD=0

# Clean up script data
clean() {
	kill $(pgrep -P $$) 2>/dev/null
	rm -r "$TMP_NAME"
	# Make cursor visible
	tput cnorm -- normal
	echo
	exit 0
}

# Get full nanoseconds
fullnano() {
	date '+%s%N'
}

CUDA() {
	ffmpeg -hwaccel cuda -i "$1" $3 "$2"
}

VAAPI() {
	ffmpeg -hwaccel vaapi -hwaccel_device /dev/dri/renderD128 -hwaccel_output_format vaapi -i "$1" $3 -c:v mjpeg_vaapi "$2"
}


# Listens for keyboard events
event_listen() {


	while read -n1 c; do

		notify-send -u low "$c"

		if [[ $c == ' ' ]]; then
			notify-send "ABC"
			kill -n SIGUSR1 $1
		fi
	done

}

# Convert frames to ascii
encode_once() {
	if [[ ! -f "$1" ]]; then
		if [[ -z $WAITING_DECODE_TIME ]]; then
	
			WAITING_DECODE_START=$(fullnano)
			while [[ ! -f "$1" ]]; do
				continue
			done
			WAITING_DECODE_TIME=$(echo "($(fullnano)-$WAITING_DECODE_START)/1000000000" | bc -l)
		else
			sleep $WAITING_DECODE_TIME
			while [[ ! -f "$1" ]]; do
				continue
			done
		fi
	fi

	jp2a "$1" --width="$WIDTH" #--color
	rm "$1" &
}

# Export frames from video
decode_frames() {
		VAAPI "$VIDEO_PATH" "%01d.jpg" 2>/dev/null
}

DEC_FPS=0

calc_decoder_fps() {
	if [[ -z "$DEC_ENDED" ]]; then
		if [[ -d /proc/$MPPID ]]; then
	
			DEC_NOW_TIME=$(fullnano)
			DEC_NOW_FRAME=$(ls | grep '.jpg' | wc -l)
			if [[ -z $DEC_LAST_FRAME ]]; then
				DEC_LAST_FRAME="$DEC_NOW_FRAME"
				DEC_LAST_TIME=$DEC_NOW_TIME
				printf '0'
				return
			fi

			DEC_FPS=$(echo "1000000000/($DEC_NOW_TIME-$DEC_LAST_TIME)*($DEC_NOW_FRAME-$DEC_LAST_FRAME) / 1" | bc)

			DEC_LAST_FRAME=$DEC_NOW_FRAME
			DEC_LAST_TIME=$DEC_NOW_TIME
		else
			DEC_ENDED=1
		fi
	fi
	printf "$DEC_FPS"


}

encode_ascii() {

	local ctr=1
	START_T=$(fullnano)
	while [ "$ctr" -lt "$FRAMES_OVER" ]; do
		for i in $(seq 1 $((${USED_THREADS}-1))); do
			fram_ind=$((ctr+i))
			encode_once "${fram_ind}.jpg" >${fram_ind}.txt &
		done

		encode_once "${ctr}.jpg" >${ctr}.txt
		ctr=$((ctr+USED_THREADS))
		wait	

		# Calculate fps and save it to a file
		END_T=$(fullnano)
		DELTA_FPS=$(echo "scale=2;1000000000/($END_T-$START_T)*$USED_THREADS" | bc -l)
		printf "$DELTA_FPS" > deltafps_ascii.txt
		START_T="${END_T}"
		calc_decoder_fps > deltafps_jpg.txt
	done

}

if [[ ! -r "/dev/dri/renderD128" ]]; then
	echo "Error: DRI render block device not found. Video acceleration is imposible" 1>&2
	exit 1 
fi

DetectGPU() {

	GLX_INFO="$(glxinfo 2>/dev/null)" # Most popular method, but it doesn't work without the X session
	if [[ $? -eq 0 ]]; then
		GPU="$(echo "$GLX_INFO" | grep 'OpenGL renderer string:' | sed 's/^[^:]*: //g')"
		return 0
	fi
	DEV_PATH="/sys/class/drm/renderD128/device"

	# Get GPU name
	PCI_BUS="$(grep 'PCI_SLOT_NAME' "$DEV_PATH/uevent" | sed 's/^[^:]*://g')"
	GPU="$(lspci 2>/dev/null)" # Works only when user is root


	# This method obtains GPU basing on vendor and revision
	if [[ $? -eq 0 ]]; then
		GPU="$(echo "$GPU" | grep "$PCI_BUS" | sed 's/^[^ ]* [^:]*: //g')"
		return 0
	else
		case "$(cat "$DEV_PATH/vendor")" in
			0x8086 )
				case "$(cat "$DEV_PATH/revision")" in
					0x04 )
						GPU="Intel HD Graphics 6xx (rev 4)"
						;;
					* )
						GPU="Intel"
						;;
				esac
				;;
			* )
				GPU="Basic DRM Graphics Card"
		esac
	fi
}


test_codec() {

	local result
	$1 "$VIDEO_PATH" out.jpg "-vframes 1"
	result=$?
	rm out.jpg 2>/dev/null
	return $result
}

# Like the command says
DetectGPU

# Get CPU name
CPUSTAT="$(lscpu)"
CPUN="$(echo "$CPUSTAT" | grep 'Model name:' | sed 's/^[^:]*: *\([^ ].*\)$/\1/g')"

# Get informations about the video
STATUS="$(ffmpeg -i "$VIDEO" 2>&1)" 								# Status data
DURATION="$(echo "$STATUS" | grep 'Duration:' | sed 's/^.*Duration: \([^,]*\),.*$/\1/g')"	# Video duration in ffmpeg format (eg. 01:05:43.54)
SECS="$(echo "$DURATION" | awk -F ':' '{ printf("%f", $1*3600+$2*60+$3) }')"			# Video duration in second
SECS_INT="$(printf "%i" "$SECS")"
FPS="$(echo "$STATUS" | grep 'fps' | sed 's/^.* \([0-9\.]*\) fps.*$/\1/g')"			# Frames Per Second
FPS_INT="$(printf "%i" "$FPS")"
SPF=$(echo "$FPS" | awk '{ printf("%f", 1/$1) }')						# Seconds Per Frame
FPN="$(echo "$FPS" | awk ' { printf("%.9f", $1/1000/1000/1000) } ')"				# Frames Per Nanosecond
FRAMES="$(echo "$FPS" "$SECS" | awk ' { printf("%i", $1*$2) } ')"				# Frames count
FRAMES_OVER=$((FRAMES+1))
PROPORTION="$(echo "$STATUS" | grep 'SAR' | sed 's/^.*DAR \([0-9\:]*\)[^0-9\:].*$/\1/g')"	# Proportion (eg. 16:9)
PROPORTION_DIV="$(echo $PROPORTION | awk -F ':' ' { printf("%f",$1/$2) } ')"			# Divided proportion (eg. 1.77)
HEIGHT="$(echo "$WIDTH" "$PROPORTION_DIV" | awk ' { printf("%i",$1/$2) } ')"			# Output video height
#FramesPerCall=$((FPS_INT*32))									# Frames per each ffmpeg call

echo $FPS $DURATION

if [[ -z $SECS || -z $FPS ]]; then
	echo "Error: Cannot get informations about the video." 1>&2
	exit 1
fi

echo "${SECS}s" "${FPS} FPS" "${FRAMES} FRAMES" "${PROPORTION} PROPORTION" "${PROPORTION_DIV} DIV_PROPORTION" "${HEIGHT} HEIGHT"

# Create a temponary directory for converter's cache in shared memory file system - /dev/shm (this file system instead of /tmp, always is tmpfs type, where /tmp defaultly may be ext, like in my SUSE system)
TMP_NAME="/dev/shm/jpvideo-$$-frames"
mkdir "$TMP_NAME"

if [[ ! $? -eq 0 ]]; then
	echo "Error: Cannot create a temporary directory for frames."
	exit 1
fi

# Get threads count
THREADS_COUNT="$(echo "$CPUSTAT" | grep '^CPU(s):' | sed 's/^[^0-9]*\([0-9].*\)$/\1/g')"
[[ -z $USED_THREADS ]] && USED_THREADS="$((THREADS_COUNT/2))"

# Move into a temporary directory
cd "$TMP_NAME"

# Check is VAAPI available. Of course other codecs like cuvid or nvenc also will be supported
if ! test_codec VAAPI; then
	echo "Error: VAAPI is not available on your platform. Maybe just replace your GPU with AMD or Intel.."
	exit 1
fi

SOUNDNAME="sound.wav"

echo "Decoding the audio..." 1>&2

# Export the sound
ffmpeg -i "$VIDEO_PATH" "$SOUNDNAME" 2>/dev/null

if [[ ! $? -eq 0 ]]; then
	echo "Warning: Cannot export sound. Video is going to be quiet" 2>&1
else
	echo "Audio decoded." 1>&2
fi


# Export frames in another process
decode_frames &
MPPID=$!


[[ $PRELOAD ]] && sleep $PRELOAD

# Convert them in another process
encode_ascii &
ASCPID=$!

#sleep 30

# Clear the screen
clear
# Make cursor invisible
tput civis -- invisible

# Play the sound
aplay "$SOUNDNAME" 2>/dev/null &
APLAYPID=$!

stats() {

printf "
\033[7;21mName: $VIDEO | Frame: ${NOW_INDEX}/${FRAMES} | Second: $((NOW_INDEX/FPS_INT))/${SECS_INT} | Player speed: ${PLAYER_FPS} FPS | FPS: ${FPS} | CPUs: ${THREADS_COUNT} | Threads: ${USED_THREADS}	
Video decoder - Codec: VAAPI (GPU) | Speed: $(cat deltafps_jpg.txt 2>/dev/null) FPS | Hardware: $GPU | \033[7;21mStatus: " 
pgrep -P $$ | grep "$MPPID" >/dev/null && printf "Working!" || printf "Finished"
printf "	
\033[7;21mAscii encoder - Codec: CPU Speed: $(cat deltafps_ascii.txt 2>/dev/null) FPS | Hardware: ${CPUN} | \033[7;21mStatus: "
pgrep -P $$ | grep "$ASCPID" >/dev/null && printf "Working!" || printf "Finished"
printf "	\033[0m"

}

play_frames() {

	# Play each frame
	COUNT_NANO=0
	START_NANO=$(fullnano)
	NOW_INDEX=0

	while [ "$NOW_INDEX" -lt "$FRAMES_OVER" ]; do
		NOW_NANO=$(fullnano)
		NOW_INDEX="$(echo "(($NOW_NANO-$START_NANO)*$FPN+1) / 1" | bc)"
		 # Move cursor to the beginning
		printf "\033[1;1H"
		if cat "${NOW_INDEX}.txt" 2>/dev/null; then
			rm "${LAST_GOOD_INDEX}.txt" 2>/dev/null &
			LAST_GOOD_INDEX="$NOW_INDEX"
		else
			cat "${LAST_GOOD_INDEX}.txt" 2>/dev/null
		fi
		PLAYER_FPS=$(echo "scale=2;1000000000/($NOW_NANO-$COUNT_NANO)" | bc)
		COUNT_NANO=$NOW_NANO
		stats
	done

}

# Trap for menu events
menu_trap() {

	if [[ $TRAP_STATUS == 1 ]]; then
		kill -n SIGCONT $APLAYPID
		play_frames
	else
		TRAP_STATUS=1

		kill -n SIGSTOP $APLAYPID

		while true; do
			sleep 1
		done
	fi

}

trap clean SIGINT SIGTERM
trap menu_trap SIGUSR1

event_listen $$ &
play_frames

# Clean up
clean
