#!/bin/bash

# Script for playing video in ascii
#
# Required programs:
#>	jp2a
#>	ffmpeg

findInPath() {

	find $(tr ':' '\n' <<< "$PATH") 2>/dev/null | grep ffmpeg >/dev/null

}

if ! findInPath ffmpeg; then
	echo "Error: ffmpeg not found." 1>&2
	exit 1
fi

if ! findInPath jp2a; then
	echo "Error: jp2a not found." 1>&2
	exit
fi

if [[ ! -z $1 ]]; then
	VIDEO="$1"
else
	echo "Error: Video not specified." 1>&2
	exit 1
fi

# Set global language to c (aka en)
export LANG="c"

VIDEO_PATH="$PWD/$VIDEO"

[[ -z $WIDTH ]] && WIDTH=200
[[ -z $PRELOAD ]] && PRELOAD=0

# Clean up script data
clean() {
	kill $(pgrep -P $$) 2>/dev/null
	rm -r "$TMP_NAME"
	# Make cursor visible
	tput cnorm -- normal
	echo
	exit 0
}

# Get full nanoseconds
fullnano() {
	date '+%s%N'
}

CPU() {
	ffmpeg -i "$1" -threads $USED_THREADS $3 "$2"
}

CUDA() {
	ffmpeg -hwaccel cuda -i "$1" $3 "$2"
}

VAAPI() {
	ffmpeg -hwaccel vaapi -hwaccel_device /dev/dri/renderD128 -hwaccel_output_format vaapi -i "$1" $3 -c:v mjpeg_vaapi "$2"
}


# Listens for keyboard events
event_listen() {


	while read -n1 c; do

		if [[ $c == ' ' ]]; then
			kill -n SIGUSR1 $1
		fi
	done

}

# Convert frames to ascii
encode_once() {
	while [[ ! -f "$1" ]]; do
		continue
	done

	jp2a "$1" --width="$WIDTH" #--color
	rm "$1" &
}

# Export frames from video
decode_frames() {
		$CODEC "$VIDEO_PATH" "%01d.jpg" 2>/dev/null
}

DEC_FPS=0

calc_decoder_fps() {
	if [[ -z "$DEC_ENDED" ]]; then
		if [[ -d /proc/$MPPID ]]; then
	
			DEC_NOW_TIME=$(fullnano)
			DEC_NOW_FRAME=$(ls | grep '.jpg' | wc -l)
			if [[ -z $DEC_LAST_FRAME ]]; then
				DEC_LAST_FRAME="$DEC_NOW_FRAME"
				DEC_LAST_TIME=$DEC_NOW_TIME
				printf '0'
				return
			fi

			DEC_FPS=$(echo "1000000000/($DEC_NOW_TIME-$DEC_LAST_TIME)*($DEC_NOW_FRAME-$DEC_LAST_FRAME) / 1" | bc)

			DEC_LAST_FRAME=$DEC_NOW_FRAME
			DEC_LAST_TIME=$DEC_NOW_TIME
		else
			DEC_ENDED=1
		fi
	fi
	printf "$DEC_FPS"


}

encode_ascii() {

	local ctr=1
	START_T=$(fullnano)
	while [ "$ctr" -lt "$FRAMES_OVER" ]; do
		for i in $(seq 1 $((${USED_THREADS}-1))); do
			fram_ind=$((ctr+i))
			encode_once "${fram_ind}.jpg" >${fram_ind}.txt &
		done

		encode_once "${ctr}.jpg" >${ctr}.txt
		ctr=$((ctr+USED_THREADS))
		wait	

		# Calculate fps and save it to a file
		END_T=$(fullnano)
		DELTA_FPS=$(echo "scale=2;1000000000/($END_T-$START_T)*$USED_THREADS" | bc -l)
		printf "$DELTA_FPS" > deltafps_ascii.txt
		START_T="${END_T}"
		calc_decoder_fps > deltafps_jpg.txt
	done

}


DetectGPU() {

	echo "Detecting GPU.." 1>&2


	# Most popular method, but it doesn't work without the X session and in tty even if DISPLAY is exported
	if [[ ! $(tty) =~ '^/dev/tty[0-9]*$' ]]; then

		GLX_INFO="$(glxinfo 2>/dev/null)"
		if [[ $? -eq 0 ]]; then
			GPU="$(echo "$GLX_INFO" | grep 'OpenGL renderer string:' | sed 's/^[^:]*: //g')"
			return 0
		fi

	fi
	DEV_PATH="/sys/class/drm/renderD128/device"

	# Get GPU name from the pci identificator

	# Add super user directories to the PATH
	export PATH="$PATH:/sbin:/usr/sbin"

	PCI_BUS="$(grep 'PCI_SLOT_NAME' "$DEV_PATH/uevent" | sed 's/^[^=]*=//g')"
	GPU="$(lspci -s "$PCI_BUS" 2>/dev/null)"

	if [[ $? -eq 0 ]]; then
		GPU="$(echo "$GPU" | sed 's/^[^ ]* [^:]*: //g')"
		return 0
	else
		# This method obtains GPU basing on vendor
		vendor="$(sed 's/^0x//g' < "$DEV_PATH/vendor")"
		case "$(cat "$DEV_PATH/vendor")" in
			8086 )
				GPU="Intel Corporation"
				;;
			# Read GPU vendor name from pci-ids network repository
			* )

				GPU="$(curl "https://pci-ids.ucw.cz/read/PC/$vendor" 2>/dev/null)"

				if [[ $? -eq 0 ]]; then
					GPU="$(echo "$GPU" | grep Name: | head -n 1 | sed -e 's/<[^>]*>//g' -e 's/^[^:]*: //g')"
				else	
					GPU="Some DRM compatible graphics card"
				fi
				;;
		esac
	fi

	echo "GPU detected." 1>&2
}


test_codec() {

	local result
	$1 "$VIDEO_PATH" out.jpg "-vframes 1" 2>/dev/null
	result=$?
	rm out.jpg 2>/dev/null
	return $result
}

testCodecs() {

	if [[ ! -z $CODEC ]]; then
		if [[ $CODEC == "CPU" ]]; then
			GPU="$CPUN"
		fi
		return 0
	fi

	echo "Testing for VAAPI.." 1>&2

	if ! test_codec VAAPI; then
		echo "Warning: VAAPI is not available on your platform. Maybe just replace your GPU with AMD or Intel.." 1>&2
	else
		CODEC=VAAPI
		echo "VAAPI works." 1>&2
		return 0
	fi

	echo "Testing for CUDA.." 1>&2

	if ! test_codec CUDA; then
		echo "Warning: CUDA also doesn't work, what means you haven't got a NVIDIA card or it is epic old." 1>&2
	else
		CODEC=CUDA
		echo "CUDA works." 1>&2
		return 0
	fi


	echo "None of supported GPU-accelerated codecs doesn't work.." 1>&2
	echo "Using CPU" 1>&2
	
	GPU="$CPUN"

	CODEC=CPU

}

# Like the command says
DetectGPU

# Get CPU name
CPUSTAT="$(lscpu)"
CPUN="$(echo "$CPUSTAT" | grep 'Model name:' | sed 's/^[^:]*: *\([^ ].*\)$/\1/g')"

# Get informations about the video
STATUS="$(ffmpeg -i "$VIDEO" 2>&1)" 								# Status data

# Create a temponary directory for converter's cache in shared memory file system - /dev/shm (this file system instead of /tmp, always is tmpfs type, where /tmp defaultly may be ext, like in my SUSE system)
TMP_NAME="/dev/shm/jpvideo-$$-frames"
mkdir "$TMP_NAME"

if [[ ! $? -eq 0 ]]; then
	echo "Error: Cannot create a temporary directory for frames." 1>&2
	exit 1
fi

# Move into a temporary directory
cd "$TMP_NAME"

#Checks for available codecs
testCodecs

DURATION="$(echo "$STATUS" | grep 'Duration:' | sed 's/^.*Duration: \([^,]*\),.*$/\1/g')"	# Video duration in ffmpeg format (eg. 01:05:43.54)
SECS="$(echo "$DURATION" | awk -F ':' '{ printf("%f", $1*3600+$2*60+$3) }')"			# Video duration in second
SECS_INT="$(printf "%i" "$SECS" 2>/dev/null)"
FPS="$(echo "$STATUS" | grep 'fps' | sed 's/^.* \([0-9\.]*\) fps.*$/\1/g')"			# Frames Per Second
FPS_INT="$(printf "%i" "$FPS" 2>/dev/null)"
SPF=$(echo "$FPS" | awk '{ printf("%f", 1/$1) }')						# Seconds Per Frame
FPN="$(echo "$FPS" | awk ' { printf("%.9f", $1/1000/1000/1000) } ')"				# Frames Per Nanosecond
FRAMES="$(echo "$FPS" "$SECS" | awk ' { printf("%i", $1*$2) } ')"				# Frames count
FRAMES_OVER=$((FRAMES+1))
PROPORTION="$(echo "$STATUS" | grep 'SAR' | sed 's/^.*DAR \([0-9\:]*\)[^0-9\:].*$/\1/g')"	# Proportion (eg. 16:9)
PROPORTION_DIV="$(echo $PROPORTION | awk -F ':' ' { printf("%f",$1/$2) } ')"			# Divided proportion (eg. 1.77)
HEIGHT="$(echo "$WIDTH" "$PROPORTION_DIV" | awk ' { printf("%i",$1/$2) } ')"			# Output video height
#FramesPerCall=$((FPS_INT*32))									# Frames per each ffmpeg call

if [[ -z $SECS || -z $FPS ]]; then
	echo "Error: Cannot get informations about the video." 1>&2
	exit 1
fi


# Get threads count
THREADS_COUNT="$(echo "$CPUSTAT" | grep '^CPU(s):' | sed 's/^[^0-9]*\([0-9].*\)$/\1/g')"
[[ -z $USED_THREADS ]] && USED_THREADS="$((THREADS_COUNT/2))"


SOUNDNAME="sound.wav"

echo "Decoding the audio..." 1>&2

# Export the sound
ffmpeg -i "$VIDEO_PATH" "$SOUNDNAME" 2>/dev/null

if [[ ! $? -eq 0 ]]; then
	echo "Warning: Cannot export sound. Video is going to be quiet" 1>&2
else
	echo "Audio decoded." 1>&2
fi


# Export frames in another process
decode_frames &
MPPID=$!


[[ $PRELOAD ]] && sleep $PRELOAD

# Convert them in another process
encode_ascii &
ASCPID=$!

#sleep 30

# Clear the screen
clear
# Make cursor invisible
tput civis -- invisible

# Play the sound
aplay "$SOUNDNAME" 2>/dev/null &
APLAYPID=$!

stats() {

printf "
\033[7;21mName: $VIDEO | Frame: ${NOW_INDEX}/${FRAMES} | Second: $((NOW_INDEX/FPS_INT))/${SECS_INT} | Player speed: ${PLAYER_FPS} FPS | FPS: ${FPS} | CPUs: ${THREADS_COUNT} | Threads: ${USED_THREADS}	
Video decoder - Codec: $CODEC | Speed: $(cat deltafps_jpg.txt 2>/dev/null) FPS | Hardware: $GPU | \033[7;21mStatus: " 
pgrep -P $$ | grep "$MPPID" >/dev/null && printf "Working!" || printf "Finished"
printf "	
\033[7;21mAscii encoder - Codec: CPU | Speed: $(cat deltafps_ascii.txt 2>/dev/null) FPS | Hardware: ${CPUN} | \033[7;21mStatus: "
pgrep -P $$ | grep "$ASCPID" >/dev/null && printf "Working!" || printf "Finished"
printf "	\033[0m"

}

play_frames() {

	# Play each frame
	COUNT_NANO=0
	START_NANO=$(fullnano)
	NOW_INDEX=0

	while [ "$NOW_INDEX" -lt "$FRAMES_OVER" ]; do
		NOW_NANO=$(fullnano)
		NOW_INDEX="$(echo "(($NOW_NANO-$START_NANO)*$FPN+1) / 1" | bc)"
		 # Move cursor to the beginning
		printf "\033[1;1H"
		if cat "${NOW_INDEX}.txt" 2>/dev/null; then
			rm "${LAST_GOOD_INDEX}.txt" 2>/dev/null &
			LAST_GOOD_INDEX="$NOW_INDEX"
		else
			cat "${LAST_GOOD_INDEX}.txt" 2>/dev/null
		fi
		PLAYER_FPS=$(echo "scale=2;1000000000/($NOW_NANO-$COUNT_NANO)" | bc)
		COUNT_NANO=$NOW_NANO
		stats
	done

}

# Trap for menu events
menu_trap() {

	if [[ $TRAP_STATUS == 1 ]]; then
		kill -n SIGCONT $APLAYPID
		play_frames
	else
		TRAP_STATUS=1

		kill -n SIGSTOP $APLAYPID

		while true; do
			sleep 1
		done
	fi

}

trap clean SIGINT SIGTERM
trap menu_trap SIGUSR1

event_listen $$ &
play_frames

# Clean up
clean
